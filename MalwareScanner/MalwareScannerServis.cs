using Common;
using Manager;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IdentityModel.Metadata;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.ServiceModel;
using System.Xml;

namespace MalwareScanner
{
    class MalwareScannerServis : IMalwareScanning
    {
        private void ReadBlackListConfig()
        {
            Console.WriteLine("Citanje iz fajla");

            string filePath = "BlackListMalwareConfig.txt";

            try
            {
                using (StreamReader sr = new StreamReader(filePath))
                {
                    string line;
                    while ((line = sr.ReadLine()) != null)
                    {
                        ProccesesDB.blackListProccesses.Add(line, new CounterAndType { Counter = 0, LevelOfSecurity = LevelOfSecurity.None });
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Došlo je do greške: " + ex.Message);
            }
        }

        private void FindUnAllowedProccesses()
        {
            ReadBlackListConfig();

            Process[] processCollection = Process.GetProcesses();
            foreach (Process p in processCollection)
            {
                if (ProccesesDB.blackListProccesses.ContainsKey(p.ProcessName.ToString()))
                {
                    RefreshLevelOfSecurity(p);

                    Console.WriteLine(p.ProcessName.ToString() + " " + ProccesesDB.blackListProccesses[p.ProcessName.ToString()].Counter + " " + ProccesesDB.blackListProccesses[p.ProcessName.ToString()].LevelOfSecurity);
                    
                }
            }
        }

        private void RefreshLevelOfSecurity(Process p)
        {
            ProccesesDB.blackListProccesses[p.ProcessName.ToString()].Counter++;

            if (ProccesesDB.blackListProccesses[p.ProcessName.ToString()].Counter == 1)
            {              
                ProccesesDB.blackListProccesses[p.ProcessName.ToString()].LevelOfSecurity = LevelOfSecurity.Information;
            }
            else if (ProccesesDB.blackListProccesses[p.ProcessName.ToString()].Counter == 2)
            {
                ProccesesDB.blackListProccesses[p.ProcessName.ToString()].LevelOfSecurity = LevelOfSecurity.Warning;
            }
            else if (ProccesesDB.blackListProccesses[p.ProcessName.ToString()].Counter > 2)
            {
                ProccesesDB.blackListProccesses[p.ProcessName.ToString()].LevelOfSecurity = LevelOfSecurity.Critical;
            }
        }

        /*public string SendAlarmToIDS()
        {
            Alarm alarm = new Alarm(DateTime.Now, "Proba", CriticalLevel.WARNING);
            FindUnAllowedProccesses();
            return alarm.ToString();
        } */

        public void SendAlarmToMS()
        {
            Console.Write("Sending from IDS to MS");
        } 

        public void SendMessage(string message, byte[] sign)
        {
            //kad je u pitanju autentifikacija putem Sertifikata
            string clientName = Formatter.ParseName(ServiceSecurityContext.Current.PrimaryIdentity.Name);

            string clientNameSign = clientName + "_sign";
            X509Certificate2 certificate = CertManager.GetCertificateFromStorage(StoreName.TrustedPeople,
                StoreLocation.LocalMachine, clientNameSign);

            /// Verify signature using SHA1 hash algorithm
            if (DigitalSignature.Verify(message, HashAlgorithm.SHA1, sign, certificate))
            {
                Console.WriteLine("Sign is valid");
            }
            else
            {
                Console.WriteLine("Sign is invalid");
            }
        }
    }
}
